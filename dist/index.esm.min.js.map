{"version":3,"file":"index.esm.min.js","sources":["../src/utils.js","../src/transitions.js","../src/router.js","../src/component-loader.js","../src/renderer.js","../src/index.js"],"sourcesContent":["/**\n * Utility functions for the router\n */\n\n/**\n * Convert a route path to a regular expression\n * @param {string} path - Route path\n * @returns {Object} - Regex and param names\n */\nexport const pathToRegex = (path) => {\n  // Skip if not a dynamic route\n  if (!path.includes(':')) {\n    return {\n      regex: new RegExp(`^${path}$`),\n      paramNames: []\n    };\n  }\n  \n  // Extract param names\n  const paramNames = (path.match(/:[^\\s/]+/g) || [])\n    .map(param => param.slice(1)); // Remove the colon\n  \n  // Convert route path to regex\n  const pattern = path\n    .replace(/:[^\\s/]+/g, '([^/]+)')\n    .replace(/\\//g, '\\\\/');\n  \n  return {\n    regex: new RegExp(`^${pattern}$`),\n    paramNames\n  };\n};\n\n/**\n * Extract params from a path using a regex and param names\n * @param {string} path - Current path\n * @param {RegExp} regex - Route regex\n * @param {Array} paramNames - Parameter names\n * @returns {Object|null} - Extracted params or null if no match\n */\nexport const extractParams = (path, regex, paramNames) => {\n  const match = path.match(regex);\n  \n  if (!match) {\n    return null;\n  }\n  \n  // Extract params\n  const params = {};\n  \n  paramNames.forEach((paramName, index) => {\n    params[paramName] = match[index + 1];\n  });\n  \n  return params;\n};\n\n/**\n * Normalize a path\n * @param {string} path - Path to normalize\n * @returns {string} - Normalized path\n */\nexport const normalizePath = (path) => {\n  // Default to home if no path\n  path = path || '/';\n  \n  // Remove trailing slash except for root\n  if (path !== '/' && path.endsWith('/')) {\n    path = path.slice(0, -1);\n  }\n  \n  // Ensure root path is always '/'\n  if (path === '') {\n    path = '/';\n  }\n  \n  return path;\n};\n\n/**\n * Find the first anchor element in an event path\n * @param {Event} event - Click event\n * @returns {HTMLAnchorElement|null} - Anchor element or null\n */\nexport const findAnchorInPath = (event) => {\n  // Get the event path (works for both regular DOM and shadow DOM)\n  const path = event.composedPath();\n  \n  // Find the first anchor element in the event path\n  for (let i = 0; i < path.length; i++) {\n    if (path[i].tagName === 'A') {\n      return path[i];\n    }\n  }\n  \n  return null;\n};\n\n/**\n * Check if a link should be handled by the router\n * @param {HTMLAnchorElement} anchor - Anchor element\n * @returns {boolean} - Whether the link should be handled\n */\nexport const shouldHandleLink = (anchor) => {\n  // Get the href attribute\n  const href = anchor.getAttribute('href');\n  \n  // Skip if no href\n  if (!href) {\n    return false;\n  }\n  \n  // Skip if it's an external link\n  if (href.startsWith('http') || href.startsWith('//')) {\n    return false;\n  }\n  \n  // Skip if it has a target\n  if (anchor.hasAttribute('target')) {\n    return false;\n  }\n  \n  // Skip if it's a download link\n  if (anchor.hasAttribute('download')) {\n    return false;\n  }\n  \n  // Skip if it's an anchor link\n  if (href.startsWith('#')) {\n    return false;\n  }\n  \n  // Skip if it's a file link (has extension)\n  if (href.match(/\\.\\w+$/)) {\n    return false;\n  }\n  \n  return true;\n};\n\nexport default {\n  pathToRegex,\n  extractParams,\n  normalizePath,\n  findAnchorInPath,\n  shouldHandleLink\n};","/**\n * Transition effects for page changes\n */\n\n/**\n * No transition effect\n * @returns {Function} Transition function\n */\nexport const none = () => {\n  return async (oldContent, newContent, rootElement) => {\n    rootElement.innerHTML = newContent;\n    return Promise.resolve();\n  };\n};\n\n/**\n * Fade transition effect\n * @param {Object} options - Transition options\n * @param {number} options.duration - Transition duration in ms\n * @returns {Function} Transition function\n */\nexport const fade = (options = {}) => {\n  const duration = options.duration || 150;\n  const onComplete = options.onComplete || (() => {});\n  \n  return async (oldContent, newContent, rootElement) => {\n    return new Promise((resolve) => {\n      // Create a full-screen overlay to hide everything during transition\n      const transitionOverlay = document.createElement('div');\n      transitionOverlay.className = 'transition-overlay';\n      transitionOverlay.style.position = 'fixed';\n      transitionOverlay.style.top = '0';\n      transitionOverlay.style.left = '0';\n      transitionOverlay.style.width = '100vw';\n      transitionOverlay.style.height = '100vh';\n      transitionOverlay.style.backgroundColor = 'var(--background-color, #ffffff)';\n      transitionOverlay.style.zIndex = '9999';\n      transitionOverlay.style.opacity = '0';\n      transitionOverlay.style.transition = `opacity ${duration}ms ease-in-out`;\n      \n      // Add the overlay to the body\n      document.body.appendChild(transitionOverlay);\n      \n      // Fade in the overlay\n      setTimeout(() => {\n        transitionOverlay.style.opacity = '1';\n      }, 0);\n      \n      // Wait for the fade-in to complete\n      setTimeout(() => {\n        // Replace the content\n        if (newContent instanceof DocumentFragment) {\n          // Clear the root element\n          rootElement.innerHTML = '';\n          // Append the DocumentFragment\n          rootElement.appendChild(newContent.cloneNode(true));\n        } else if (typeof newContent === 'string') {\n          // Set the HTML content\n          rootElement.innerHTML = newContent;\n        } else {\n          console.error('Unsupported content type:', typeof newContent);\n          rootElement.innerHTML = String(newContent);\n        }\n        \n        // Fade out the overlay\n        transitionOverlay.style.opacity = '0';\n        \n        // Remove the overlay after the transition completes\n        setTimeout(() => {\n          if (document.body.contains(transitionOverlay)) {\n            document.body.removeChild(transitionOverlay);\n          }\n          \n          // Call the onComplete callback\n          onComplete();\n          \n          // Clean up any other transition overlays that might be stuck\n          const overlays = document.querySelectorAll('.transition-overlay');\n          overlays.forEach(overlay => {\n            if (document.body.contains(overlay) && overlay !== transitionOverlay) {\n              console.log('Removing stale transition overlay');\n              document.body.removeChild(overlay);\n            }\n          });\n          \n          resolve();\n        }, duration);\n      }, duration);\n      \n      // Safety timeout to ensure overlay is removed even if something goes wrong\n      setTimeout(() => {\n        if (document.body.contains(transitionOverlay)) {\n          console.log('Safety timeout: removing transition overlay');\n          document.body.removeChild(transitionOverlay);\n        }\n      }, duration * 3);\n    });\n  };\n};\n\n/**\n * Slide transition effect\n * @param {Object} options - Transition options\n * @param {string} options.direction - Slide direction ('left', 'right', 'up', 'down')\n * @param {number} options.duration - Transition duration in ms\n * @returns {Function} Transition function\n */\nexport const slide = (options = {}) => {\n  const direction = options.direction || 'left';\n  const duration = options.duration || 300;\n  \n  return async (oldContent, newContent, rootElement) => {\n    return new Promise((resolve) => {\n      // Create a container for the old content\n      const oldContainer = document.createElement('div');\n      oldContainer.style.position = 'absolute';\n      oldContainer.style.top = '0';\n      oldContainer.style.left = '0';\n      oldContainer.style.width = '100%';\n      oldContainer.style.height = '100%';\n      oldContainer.style.transition = `transform ${duration}ms ease-in-out`;\n      \n      // Set old content\n      if (typeof oldContent === 'string') {\n        oldContainer.innerHTML = oldContent;\n      } else {\n        console.warn('Old content is not a string, using empty content');\n        oldContainer.innerHTML = '';\n      }\n      \n      // Create a container for the new content\n      const newContainer = document.createElement('div');\n      newContainer.style.position = 'absolute';\n      newContainer.style.top = '0';\n      newContainer.style.left = '0';\n      newContainer.style.width = '100%';\n      newContainer.style.height = '100%';\n      newContainer.style.transition = `transform ${duration}ms ease-in-out`;\n      \n      // Set new content\n      if (newContent instanceof DocumentFragment) {\n        newContainer.appendChild(newContent.cloneNode(true));\n      } else if (typeof newContent === 'string') {\n        newContainer.innerHTML = newContent;\n      } else {\n        console.error('Unsupported content type:', typeof newContent);\n        newContainer.innerHTML = String(newContent);\n      }\n      \n      // Set initial positions\n      let initialTransform = '';\n      let finalTransform = '';\n      \n      switch (direction) {\n        case 'left':\n          initialTransform = 'translateX(100%)';\n          finalTransform = 'translateX(-100%)';\n          break;\n        case 'right':\n          initialTransform = 'translateX(-100%)';\n          finalTransform = 'translateX(100%)';\n          break;\n        case 'up':\n          initialTransform = 'translateY(100%)';\n          finalTransform = 'translateY(-100%)';\n          break;\n        case 'down':\n          initialTransform = 'translateY(-100%)';\n          finalTransform = 'translateY(100%)';\n          break;\n      }\n      \n      newContainer.style.transform = initialTransform;\n      \n      // Clear the root element and add both containers\n      rootElement.innerHTML = '';\n      rootElement.style.position = 'relative';\n      rootElement.style.overflow = 'hidden';\n      rootElement.appendChild(oldContainer);\n      rootElement.appendChild(newContainer);\n      \n      // Trigger the transition\n      setTimeout(() => {\n        oldContainer.style.transform = finalTransform;\n        newContainer.style.transform = 'translateX(0)';\n        \n        // Clean up after the transition\n        setTimeout(() => {\n          // Clear the root element\n          rootElement.innerHTML = '';\n          \n          // Add the new content\n          if (newContent instanceof DocumentFragment) {\n            rootElement.appendChild(newContent.cloneNode(true));\n          } else if (typeof newContent === 'string') {\n            rootElement.innerHTML = newContent;\n          } else {\n            console.error('Unsupported content type:', typeof newContent);\n            rootElement.innerHTML = String(newContent);\n          }\n          \n          // Reset styles\n          rootElement.style.position = '';\n          rootElement.style.overflow = '';\n          resolve();\n        }, duration);\n      }, 10);\n    });\n  };\n};\n\n/**\n * Custom transition effect\n * @param {Function} fn - Custom transition function\n * @returns {Function} Transition function\n */\nexport const custom = (fn) => {\n  return async (oldContent, newContent, rootElement) => {\n    return fn(oldContent, newContent, rootElement);\n  };\n};\n\nexport default {\n  none,\n  fade,\n  slide,\n  custom\n};","/**\n * SPA Router using the History API\n */\nimport { pathToRegex, extractParams, normalizePath, findAnchorInPath, shouldHandleLink } from './utils.js';\nimport { fade } from './transitions.js';\n\n/**\n * Router class for handling SPA navigation\n */\nexport class Router {\n  /**\n   * Create a new router\n   * @param {Object} options - Router options\n   * @param {Object} options.routes - Route definitions (optional)\n   * @param {string} options.rootElement - Root element selector\n   * @param {Function} options.errorHandler - 404 error handler\n   * @param {Function} options.transition - Transition function\n   */\n  constructor(options = {}) {\n    this.routes = {};\n    this.rootElement = options.rootElement || '#app';\n    this.errorHandler = options.errorHandler || this.defaultErrorHandler;\n    this.transition = options.transition || fade({ duration: 150 });\n    this.currentRoute = null;\n    this.loading = false;\n    this.middlewares = [];\n    \n    // Register initial routes if provided\n    if (options.routes) {\n      this.registerRoutes(options.routes);\n    }\n    \n    // Initialize\n    this.init();\n  }\n\n  /**\n   * Initialize the router\n   */\n  init() {\n    console.log('Router initializing...');\n    \n    // Handle initial route immediately if document is already loaded\n    if (document.readyState === 'complete' || document.readyState === 'interactive') {\n      console.log('Document already loaded, navigating to:', window.location.pathname);\n      this.navigate(window.location.pathname, false);\n    }\n    \n    // Also handle when DOM is fully loaded\n    window.addEventListener('DOMContentLoaded', () => {\n      console.log('DOMContentLoaded event, navigating to:', window.location.pathname);\n      this.navigate(window.location.pathname, false);\n    });\n    \n    // Handle popstate events (browser back/forward)\n    window.addEventListener('popstate', (e) => {\n      console.log('Popstate event, navigating to:', window.location.pathname);\n      this.navigate(window.location.pathname, false);\n    });\n    \n    // Intercept all clicks at the document level (including those from Shadow DOM)\n    document.addEventListener('click', (e) => {\n      // Skip if modifier keys are pressed\n      if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n      \n      // Find anchor element in the event path\n      const anchor = findAnchorInPath(e);\n      \n      // Skip if no anchor found\n      if (!anchor) return;\n      \n      // Check if the link should be handled by the router\n      if (!shouldHandleLink(anchor)) return;\n      \n      // Get the href attribute\n      const href = anchor.getAttribute('href');\n      \n      // Prevent default behavior\n      e.preventDefault();\n      \n      // Navigate to the link\n      this.navigate(href);\n      \n      console.log('Intercepted click on link:', href);\n    }, { capture: true }); // Use capture to get events before they reach the shadow DOM\n  }\n\n  /**\n   * Register multiple routes\n   * @param {Object} routes - Route definitions\n   */\n  registerRoutes(routes) {\n    Object.entries(routes).forEach(([path, routeConfig]) => {\n      this.addRoute(path, routeConfig);\n    });\n  }\n\n  /**\n   * Add a single route\n   * @param {string} path - Route path\n   * @param {Object} routeConfig - Route configuration\n   */\n  addRoute(path, routeConfig) {\n    // Convert path to regex for matching\n    const { regex, paramNames } = pathToRegex(path);\n    \n    // Store the route with its regex and param names\n    this.routes[path] = {\n      ...routeConfig,\n      regex,\n      paramNames,\n      path\n    };\n  }\n\n  /**\n   * Remove a route\n   * @param {string} path - Route path\n   */\n  removeRoute(path) {\n    delete this.routes[path];\n  }\n\n  /**\n   * Get the current route\n   * @returns {Object|null} - Current route\n   */\n  getCurrentRoute() {\n    return this.currentRoute;\n  }\n\n  /**\n   * Go back in history\n   */\n  back() {\n    window.history.back();\n  }\n\n  /**\n   * Go forward in history\n   */\n  forward() {\n    window.history.forward();\n  }\n\n  /**\n   * Add middleware\n   * @param {Function} middleware - Middleware function\n   */\n  use(middleware) {\n    this.middlewares.push(middleware);\n  }\n\n  /**\n   * Navigate to a route\n   * @param {string} path - Route path\n   * @param {boolean} pushState - Whether to push state to history\n   */\n  async navigate(path, pushState = true) {\n    console.log(`Router navigating to: ${path}`);\n    \n    // Skip if already loading\n    if (this.loading) {\n      console.log('Already loading, skipping navigation');\n      return;\n    }\n    \n    // Set loading state\n    this.loading = true;\n    \n    // Normalize path\n    path = normalizePath(path);\n    \n    // Find matching route\n    const route = this.findRoute(path);\n    console.log('Found route:', route ? 'yes' : 'no');\n    \n    // Update history if needed\n    if (pushState) {\n      console.log('Updating history with path:', path);\n      window.history.pushState({ path }, document.title, path);\n    }\n    \n    // Get root element\n    const rootElement = document.querySelector(this.rootElement);\n    if (!rootElement) {\n      console.error(`Root element \"${this.rootElement}\" not found`);\n      this.loading = false;\n      return;\n    }\n    \n    try {\n      // Get the current content for transitions\n      const oldContent = rootElement.innerHTML;\n      \n      // If route exists, run middleware\n      if (route) {\n        // Run middleware\n        const from = this.currentRoute ? this.currentRoute.path : null;\n        const to = { path, params: route.params };\n        \n        // Create a next function for middleware\n        let index = 0;\n        const next = async (nextPath) => {\n          // If nextPath is provided, navigate to it instead\n          if (nextPath) {\n            this.loading = false;\n            return this.navigate(nextPath);\n          }\n          \n          // Run the next middleware\n          if (index < this.middlewares.length) {\n            const middleware = this.middlewares[index++];\n            return middleware(to, from, next);\n          }\n          \n          // No more middleware, continue with navigation\n          return this.renderRoute(route, rootElement, oldContent);\n        };\n        \n        // Start middleware chain\n        await next();\n      } else {\n        // Handle 404\n        console.log('Route not found, showing 404 page');\n        \n        // Call the error handler\n        const errorContent = this.errorHandler(path, rootElement);\n        \n        // Apply transition\n        await this.transition(oldContent, errorContent, rootElement);\n        \n        // Ensure any transition overlays are removed\n        setTimeout(() => {\n          const overlays = document.querySelectorAll('.transition-overlay');\n          overlays.forEach(overlay => {\n            if (document.body.contains(overlay)) {\n              document.body.removeChild(overlay);\n            }\n          });\n          \n          // Dispatch a custom event to signal that the error page has been rendered\n          document.dispatchEvent(new CustomEvent('error-page-rendered', {\n            detail: { path }\n          }));\n        }, 100);\n      }\n    } catch (error) {\n      console.error('Error rendering route:', error);\n      \n      // Handle errors\n      rootElement.innerHTML = `<div class=\"error\">Error loading page: ${error.message}</div>`;\n    } finally {\n      // Clear loading state\n      this.loading = false;\n    }\n  }\n\n  /**\n   * Render a route\n   * @param {Object} route - Route to render\n   * @param {HTMLElement} rootElement - Root element\n   * @param {string} oldContent - Old content for transitions\n   */\n  async renderRoute(route, rootElement, oldContent) {\n    // Set current route\n    this.currentRoute = route;\n    \n    // Get view content\n    let content;\n    \n    // Check for beforeEnter guard\n    if (route.beforeEnter) {\n      // Create a next function for the guard\n      const next = (nextPath) => {\n        if (nextPath) {\n          this.loading = false;\n          return this.navigate(nextPath);\n        }\n        return true;\n      };\n      \n      // Run the guard\n      const result = await route.beforeEnter(route, this.currentRoute, next);\n      \n      // If the guard returned false or a promise that resolves to false, abort\n      if (result === false) {\n        this.loading = false;\n        return;\n      }\n    }\n    \n    try {\n      if (typeof route.view === 'function') {\n        // If view is a function, call it with params\n        console.log('Calling view function with params:', route.params);\n        content = await route.view(route.params);\n      } else if (typeof route.view === 'string') {\n        // If view is a string, treat it as HTML\n        console.log('Using string view');\n        content = route.view;\n      } else if (route.component) {\n        // If route has a component, handle it\n        console.log('Creating component:', route.component);\n        \n        if (typeof route.component === 'string') {\n          // If component is a string, create the element\n          const component = document.createElement(route.component);\n          \n          // Add props if provided\n          if (route.props) {\n            Object.entries(route.props).forEach(([key, value]) => {\n              component[key] = value;\n            });\n          }\n          \n          content = component.outerHTML;\n        } else if (typeof route.component === 'function') {\n          // If component is a function, it's a dynamic import\n          const module = await route.component();\n          const Component = module.default || module;\n          \n          // Create the component\n          const component = new Component(route.props);\n          content = component.render ? component.render() : component.outerHTML;\n        }\n      } else {\n        // Default to empty content\n        console.log('No view or component found, using empty content');\n        content = '';\n      }\n      \n      // Apply transition\n      await this.transition(oldContent, content, rootElement);\n      \n      // Call afterRender if provided\n      if (route.afterRender) {\n        console.log('Calling afterRender function');\n        try {\n          route.afterRender(route.params);\n        } catch (error) {\n          console.error('Error in afterRender:', error);\n        }\n      }\n      \n      // Dispatch route changed event\n      window.dispatchEvent(new CustomEvent('route-changed', {\n        detail: { path: route.path, route }\n      }));\n      \n      // Remove the initial loading overlay if it exists\n      const initialOverlay = document.getElementById('initial-loading-overlay');\n      if (initialOverlay) {\n        initialOverlay.style.opacity = '0';\n        setTimeout(() => {\n          if (initialOverlay.parentNode) {\n            initialOverlay.parentNode.removeChild(initialOverlay);\n          }\n        }, 150);\n      }\n    } catch (error) {\n      console.error('Error rendering route content:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find a route that matches the path\n   * @param {string} path - Route path\n   * @returns {Object|null} - Matching route or null\n   */\n  findRoute(path) {\n    // Check for exact match\n    if (this.routes[path]) {\n      return { ...this.routes[path] };\n    }\n    \n    // Special case for root path\n    if (path === '/' && this.routes['/']) {\n      return { ...this.routes['/'] };\n    }\n    \n    // Check for dynamic routes\n    for (const routePath in this.routes) {\n      const route = this.routes[routePath];\n      \n      // Skip if not a dynamic route\n      if (!routePath.includes(':')) continue;\n      \n      // Extract params\n      const params = extractParams(path, route.regex, route.paramNames);\n      \n      if (params) {\n        // Return route with params\n        return {\n          ...route,\n          params\n        };\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Default 404 error handler\n   * @param {string} path - Route path\n   * @param {HTMLElement} rootElement - Root element\n   * @returns {string} - Error page HTML\n   */\n  defaultErrorHandler(path) {\n    return `\n      <div class=\"error-page\">\n        <h1>404 - Page Not Found</h1>\n        <p>The page \"${path}\" could not be found.</p>\n        <a href=\"/\" class=\"back-link\">Go back to home</a>\n      </div>\n    `;\n  }\n}\n\nexport default Router;","/**\n * Component Loader Utility\n *\n * Handles automatic detection and loading of web components from HTML content\n */\n\n/**\n * Extracts module script sources from HTML content\n * @param {Document} doc - Parsed HTML document\n * @returns {string[]} - Array of script sources\n */\nexport function extractModuleScriptSources(doc) {\n  // Extract script tags from both body and the entire document\n  // This ensures we catch scripts at the root level of HTML fragments\n  const bodyScriptTags = Array.from(doc.body.querySelectorAll('script[type=\"module\"]'));\n  const allScriptTags = Array.from(doc.querySelectorAll('script[type=\"module\"]'));\n  \n  // Combine and deduplicate script tags\n  const scriptTags = [...new Set([...bodyScriptTags, ...allScriptTags])];\n  \n  // Extract src attributes\n  const scriptSources = scriptTags.map(script => script.getAttribute('src')).filter(src => src);\n  \n  if (scriptSources.length > 0) {\n    console.log(`Found ${scriptSources.length} module scripts:`, scriptSources);\n  }\n  \n  return scriptSources;\n}\n\n/**\n * Executes inline script tags from HTML content\n * @param {Document} doc - Parsed HTML document\n * @returns {Promise<number>} - Number of executed inline scripts\n */\n/**\n * Execute inline scripts by replacing them with new script elements\n * This forces the browser to execute the scripts\n * @param {Document} doc - Parsed HTML document\n * @returns {number} - Number of executed inline scripts\n */\nexport async function executeInlineScripts(doc) {\n  return function reexecuteInlineScripts(container) {\n    // Execute inline scripts only (ignore scripts with src)\n    const scripts = container.querySelectorAll('script:not([src])');\n    let count = scripts.length;\n    \n    scripts.forEach(oldScript => {\n      const newScript = document.createElement('script');\n      [...oldScript.attributes].forEach(attr =>\n        newScript.setAttribute(attr.name, attr.value)\n      );\n      newScript.textContent = oldScript.textContent;\n      oldScript.replaceWith(newScript); // Maintains position in DOM\n    });\n    \n    return count;\n  };\n}\n\n/**\n * Filters out script tags from HTML content\n * @param {HTMLElement} element - Element to filter scripts from\n * @param {boolean} keepScripts - Whether to keep script tags in the output (default: false)\n * @returns {DocumentFragment} - Document fragment with scripts removed or preserved\n */\nexport function filterScriptTags(element, keepScripts = false) {\n  const tempDiv = document.createElement('div');\n  \n  // Clone all child nodes, optionally excluding script tags\n  Array.from(element.children).forEach(child => {\n    if (keepScripts || child.tagName !== 'SCRIPT') {\n      tempDiv.appendChild(child.cloneNode(true));\n    }\n  });\n  \n  return tempDiv;\n}\n\n/**\n * Extracts all script tags from a document and creates new script elements\n * that will be executed when added to the DOM\n * @param {Document} doc - Parsed HTML document\n * @returns {Array<HTMLScriptElement>} - Array of new script elements\n */\nexport function extractAndCloneScripts(doc) {\n  // Get all script tags from the document\n  const scriptTags = Array.from(doc.querySelectorAll('script'));\n  \n  if (scriptTags.length > 0) {\n    console.log(`Found ${scriptTags.length} script tags to clone`);\n  }\n  \n  // Create new script elements with the same attributes and content\n  return scriptTags.map(oldScript => {\n    const newScript = document.createElement('script');\n    \n    // Copy all attributes\n    Array.from(oldScript.attributes).forEach(attr => {\n      newScript.setAttribute(attr.name, attr.value);\n    });\n    \n    // Copy the content\n    newScript.textContent = oldScript.textContent;\n    \n    // If it's a src script, ensure the URL is absolute\n    if (newScript.src && !newScript.src.startsWith('http://') && !newScript.src.startsWith('https://')) {\n      const baseUrl = window.location.origin;\n      const absoluteSrc = newScript.src.startsWith('/')\n        ? `${baseUrl}${newScript.src}`\n        : `${baseUrl}/${newScript.src}`;\n      newScript.src = absoluteSrc;\n    }\n    \n    return newScript;\n  });\n}\n\n/**\n * Creates a document fragment from HTML content and ensures scripts are properly handled\n * @param {Document} doc - Parsed HTML document\n * @returns {DocumentFragment} - Document fragment with content and scripts that will execute\n */\nexport function createFragmentWithScripts(doc) {\n  // Create a fragment to hold the content\n  const fragment = document.createDocumentFragment();\n  \n  // Clone all children from the body\n  Array.from(doc.body.children).forEach(child => {\n    // Skip script tags, we'll handle them separately\n    if (child.tagName !== 'SCRIPT') {\n      fragment.appendChild(child.cloneNode(true));\n    }\n  });\n  \n  // Extract and clone script tags\n  const scriptElements = extractAndCloneScripts(doc);\n  \n  // Add the script elements to the fragment\n  scriptElements.forEach(script => {\n    fragment.appendChild(script);\n  });\n  \n  // Extract module script sources\n  const moduleScripts = extractModuleScriptSources(doc);\n  \n  // Create and add module scripts to the fragment\n  if (moduleScripts && moduleScripts.length > 0) {\n    console.log(`Adding ${moduleScripts.length} module scripts to the fragment`);\n    \n    moduleScripts.forEach(src => {\n      // Create a new script element\n      const script = document.createElement('script');\n      script.type = 'module';\n      \n      // Convert to absolute URL if needed\n      if (src.startsWith('http://') || src.startsWith('https://')) {\n        script.src = src;\n      } else {\n        // For local scripts, create absolute URL based on current origin\n        const baseUrl = window.location.origin;\n        const absoluteSrc = src.startsWith('/')\n          ? `${baseUrl}${src}`\n          : `${baseUrl}/${src}`;\n        script.src = absoluteSrc;\n      }\n      \n      console.log(`Adding module script: ${script.src}`);\n      fragment.appendChild(script);\n    });\n  }\n  \n  return fragment;\n}\n\nexport default {\n  extractModuleScriptSources,\n  executeInlineScripts,\n  filterScriptTags,\n  extractAndCloneScripts,\n  createFragmentWithScripts\n};","/**\n * Enhanced renderer for SPA Router\n * Provides component preservation and translation support\n */\nimport { extractModuleScriptSources, executeInlineScripts, filterScriptTags } from './component-loader.js';\n\n/**\n * Create a content renderer that handles translations and component preservation\n * @param {Object} options - Renderer options\n * @param {Function} options.translateContainer - Function to translate a container\n * @param {Function} options.applyRTLToDocument - Function to apply RTL direction to document\n * @param {Boolean} options.handleScripts - Whether to handle scripts in content (default: true)\n * @param {Boolean} options.keepScripts - Whether to keep script tags in the output (default: false)\n * @returns {Function} Renderer function\n */\nexport function createRenderer(options = {}) {\n  const translateContainer = options.translateContainer || ((container) => {});\n  const applyRTLToDocument = options.applyRTLToDocument || (() => {});\n  const handleScripts = options.handleScripts !== false; // Default to true\n  const keepScripts = options.keepScripts === true; // Default to false\n\n  return async (content, element) => {\n    // Create a new container with absolute positioning (off-screen)\n    const newContainer = document.createElement('div');\n    newContainer.style.position = 'absolute';\n    newContainer.style.top = '0';\n    newContainer.style.left = '0';\n    newContainer.style.width = '100%';\n    newContainer.style.height = '100%';\n    newContainer.style.opacity = '0'; // Start hidden\n    newContainer.style.zIndex = '1'; // Above the current content\n    \n    // Handle different content types\n    let doc;\n    \n    if (content instanceof DocumentFragment) {\n      console.log('Received DocumentFragment as content');\n      // Create a temporary document to hold the fragment\n      doc = document.implementation.createHTMLDocument('');\n      \n      // Clone the fragment to avoid modifying the original\n      const clonedFragment = content.cloneNode(true);\n      \n      // Append the fragment to the document body\n      doc.body.appendChild(clonedFragment);\n    } else if (typeof content === 'string') {\n      console.log('Received string as content');\n      // Parse the content into DOM\n      const parser = new DOMParser();\n      doc = parser.parseFromString(content, 'text/html');\n    } else {\n      console.error('Unsupported content type:', typeof content);\n      throw new Error('Unsupported content type: ' + typeof content);\n    }\n    \n    // Handle scripts if enabled\n    let scriptExecutor;\n    let moduleScripts = [];\n    let scriptElements = [];\n    \n    if (handleScripts) {\n      // Extract module scripts but don't execute them yet\n      // We'll store them to execute after the DOM is updated\n      moduleScripts = extractModuleScriptSources(doc);\n      \n      // Get the script executor function to be called after content is added to DOM\n      scriptExecutor = await executeInlineScripts(doc);\n      \n      // If keepScripts is true, collect all script elements to be properly inserted later\n      if (keepScripts) {\n        console.log('Collecting script tags to properly insert them later');\n        scriptElements = Array.from(doc.querySelectorAll('script')).map(script => {\n          // Create a clone of the script element\n          const newScript = document.createElement('script');\n          \n          // Copy all attributes\n          Array.from(script.attributes).forEach(attr => {\n            newScript.setAttribute(attr.name, attr.value);\n          });\n          \n          // Copy the content\n          newScript.textContent = script.textContent;\n          \n          // Remove the original script from the DOM\n          if (script.parentNode) {\n            script.parentNode.removeChild(script);\n          }\n          \n          return newScript;\n        });\n        \n        console.log(`Collected ${scriptElements.length} script elements`);\n      } else {\n        // Filter out script tags from the content\n        const bodyWithoutScripts = filterScriptTags(doc.body, false);\n        \n        // Clear the body and append each child individually\n        while (doc.body.firstChild) {\n          doc.body.removeChild(doc.body.firstChild);\n        }\n        \n        Array.from(bodyWithoutScripts.children).forEach(child => {\n          doc.body.appendChild(child);\n        });\n      }\n    }\n    \n    // Get all existing web components in the current DOM to preserve\n    const existingComponents = {};\n    const customElements = element.querySelectorAll('*').filter(el => el.tagName.includes('-'));\n    \n    customElements.forEach(el => {\n      const id = el.tagName.toLowerCase();\n      existingComponents[id] = el;\n    });\n    \n    // Process the new content\n    Array.from(doc.body.children).forEach(child => {\n      // If it's a custom element that already exists, skip it (we'll keep the existing one)\n      if (child.tagName.includes('-') && existingComponents[child.tagName.toLowerCase()]) {\n        console.log(`Preserving existing component: ${child.tagName.toLowerCase()}`);\n      } else {\n        // Otherwise, add the new element to the container\n        newContainer.appendChild(child);\n      }\n    });\n    \n    // Translate all text in new DOM\n    if (translateContainer) {\n      translateContainer(newContainer);\n    }\n    \n    // Add preserved components back to the new container\n    Object.values(existingComponents).forEach(component => {\n      newContainer.appendChild(component);\n    });\n    \n    // Add the new container to the DOM\n    element.appendChild(newContainer);\n    \n    // Apply RTL direction if needed\n    if (applyRTLToDocument) {\n      applyRTLToDocument();\n    }\n    \n    // Short delay to ensure everything is ready, then show new content and remove old\n    setTimeout(() => {\n      // Remove all old content\n      Array.from(element.children).forEach(child => {\n        if (child !== newContainer) {\n          element.removeChild(child);\n        }\n      });\n      \n      // Show the new content by changing position and opacity\n      newContainer.style.position = 'relative';\n      newContainer.style.opacity = '1';\n      \n      // Execute inline scripts if we have a script executor\n      if (scriptExecutor) {\n        console.log('Executing inline scripts');\n        scriptExecutor(newContainer);\n      }\n      \n      // Insert collected script elements if keepScripts is true\n      if (scriptElements && scriptElements.length > 0) {\n        console.log(`Inserting ${scriptElements.length} script elements into the DOM`);\n        scriptElements.forEach(script => {\n          if (script.type === 'module') {\n            console.log(`Inserting module script: ${script.src || 'inline'}`);\n          } else {\n            console.log(`Inserting regular script: ${script.src || 'inline'}`);\n          }\n          \n          // If it's a src script, ensure the URL is absolute\n          if (script.src && !script.src.startsWith('http://') && !script.src.startsWith('https://')) {\n            const baseUrl = window.location.origin;\n            const absoluteSrc = script.src.startsWith('/')\n              ? `${baseUrl}${script.src}`\n              : `${baseUrl}/${script.src}`;\n            script.src = absoluteSrc;\n          }\n          \n          // Append to the document to execute it\n          document.head.appendChild(script);\n        });\n      }\n      \n      // Now that the DOM is updated, import and execute module scripts\n      if (moduleScripts.length > 0) {\n        console.log('Importing module scripts after DOM update');\n        \n        // Get the base URL of the current application\n        const baseUrl = window.location.origin;\n        \n        // Import each module script\n        moduleScripts.forEach(src => {\n          // Create a new script element\n          const script = document.createElement('script');\n          script.type = 'module';\n          \n          // Convert to absolute URL if needed\n          if (src.startsWith('http://') || src.startsWith('https://')) {\n            script.src = src;\n          } else {\n            // For local scripts, create absolute URL based on current origin\n            const absoluteSrc = src.startsWith('/')\n              ? `${baseUrl}${src}`\n              : `${baseUrl}/${src}`;\n            script.src = absoluteSrc;\n          }\n          \n          console.log(`Loading module script: ${script.src}`);\n          document.head.appendChild(script);\n        });\n      }\n      \n      // Dispatch a custom event to notify that the SPA transition is complete\n      window.dispatchEvent(new CustomEvent('spa-transition-end'));\n    }, 50);\n  };\n}\n\n/**\n * Create a default error handler\n * @param {Object} options - Error handler options\n * @returns {Function} Error handler function\n */\nexport function createErrorHandler(options = {}) {\n  return (path) => {\n    return `\n      <div class=\"error-page\">\n        <h1>404 - Page Not Found</h1>\n        <p>The page \"${path}\" could not be found.</p>\n        <a href=\"/\" class=\"back-link\">Go back to home</a>\n      </div>\n    `;\n  };\n}\n\nexport default {\n  createRenderer,\n  createErrorHandler\n};","/**\n * @profullstack/spa-router\n * A lightweight, feature-rich SPA router with smooth transitions and Shadow DOM support\n */\n\nimport Router from './router.js';\nimport * as transitions from './transitions.js';\nimport * as utils from './utils.js';\nimport * as renderer from './renderer.js';\nimport * as componentLoader from './component-loader.js';\n\n// Export the main components\nexport { Router, transitions, utils, renderer, componentLoader };\n\n// Export a default object for UMD builds\nexport default {\n  Router,\n  transitions,\n  utils,\n  renderer,\n  componentLoader\n};"],"names":["pathToRegex","path","includes","regex","RegExp","paramNames","match","map","param","slice","pattern","replace","extractParams","params","forEach","paramName","index","normalizePath","endsWith","findAnchorInPath","event","composedPath","i","length","tagName","shouldHandleLink","anchor","href","getAttribute","startsWith","hasAttribute","utils","none","async","oldContent","newContent","rootElement","innerHTML","Promise","resolve","fade","options","duration","onComplete","transitionOverlay","document","createElement","className","style","position","top","left","width","height","backgroundColor","zIndex","opacity","transition","body","appendChild","setTimeout","DocumentFragment","cloneNode","console","error","String","contains","removeChild","querySelectorAll","overlay","log","slide","direction","oldContainer","warn","newContainer","initialTransform","finalTransform","transform","overflow","custom","fn","transitions","Router","constructor","this","routes","errorHandler","defaultErrorHandler","currentRoute","loading","middlewares","registerRoutes","init","readyState","window","location","pathname","navigate","addEventListener","e","metaKey","ctrlKey","shiftKey","preventDefault","capture","Object","entries","routeConfig","addRoute","removeRoute","getCurrentRoute","back","history","forward","use","middleware","push","pushState","route","findRoute","title","querySelector","from","to","next","nextPath","renderRoute","errorContent","dispatchEvent","CustomEvent","detail","message","content","beforeEnter","view","component","props","key","value","outerHTML","module","default","render","afterRender","initialOverlay","getElementById","parentNode","routePath","extractModuleScriptSources","doc","bodyScriptTags","Array","allScriptTags","scriptSources","Set","script","filter","src","executeInlineScripts","container","scripts","count","oldScript","newScript","attributes","attr","setAttribute","name","textContent","replaceWith","filterScriptTags","element","keepScripts","tempDiv","children","child","extractAndCloneScripts","scriptTags","baseUrl","origin","absoluteSrc","createFragmentWithScripts","fragment","createDocumentFragment","moduleScripts","type","componentLoader","createRenderer","translateContainer","applyRTLToDocument","handleScripts","scriptExecutor","implementation","createHTMLDocument","clonedFragment","Error","parser","DOMParser","parseFromString","scriptElements","bodyWithoutScripts","firstChild","existingComponents","el","id","toLowerCase","values","head","createErrorHandler","renderer"],"mappings":"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"}