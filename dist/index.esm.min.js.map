{"version":3,"file":"index.esm.min.js","sources":["../src/utils.js","../src/transitions.js","../logger.js","../src/router.js","../src/component-loader.js","../src/renderer.js","../src/index.js"],"sourcesContent":["/**\n * Utility functions for the router\n */\n\n/**\n * Convert a route path to a regular expression\n * @param {string} path - Route path\n * @returns {Object} - Regex and param names\n */\nexport const pathToRegex = (path) => {\n  // Skip if not a dynamic route\n  if (!path.includes(':')) {\n    return {\n      regex: new RegExp(`^${path}$`),\n      paramNames: []\n    };\n  }\n  \n  // Extract param names\n  const paramNames = (path.match(/:[^\\s/]+/g) || [])\n    .map(param => param.slice(1)); // Remove the colon\n  \n  // Convert route path to regex\n  const pattern = path\n    .replace(/:[^\\s/]+/g, '([^/]+)')\n    .replace(/\\//g, '\\\\/');\n  \n  return {\n    regex: new RegExp(`^${pattern}$`),\n    paramNames\n  };\n};\n\n/**\n * Extract params from a path using a regex and param names\n * @param {string} path - Current path\n * @param {RegExp} regex - Route regex\n * @param {Array} paramNames - Parameter names\n * @returns {Object|null} - Extracted params or null if no match\n */\nexport const extractParams = (path, regex, paramNames) => {\n  const match = path.match(regex);\n  \n  if (!match) {\n    return null;\n  }\n  \n  // Extract params\n  const params = {};\n  \n  paramNames.forEach((paramName, index) => {\n    params[paramName] = match[index + 1];\n  });\n  \n  return params;\n};\n\n/**\n * Normalize a path\n * @param {string} path - Path to normalize\n * @returns {string} - Normalized path\n */\nexport const normalizePath = (path) => {\n  // Default to home if no path\n  path = path || '/';\n  \n  // Remove trailing slash except for root\n  if (path !== '/' && path.endsWith('/')) {\n    path = path.slice(0, -1);\n  }\n  \n  // Ensure root path is always '/'\n  if (path === '') {\n    path = '/';\n  }\n  \n  return path;\n};\n\n/**\n * Find the first anchor element in an event path\n * @param {Event} event - Click event\n * @returns {HTMLAnchorElement|null} - Anchor element or null\n */\nexport const findAnchorInPath = (event) => {\n  // Get the event path (works for both regular DOM and shadow DOM)\n  const path = event.composedPath();\n  \n  // Find the first anchor element in the event path\n  for (let i = 0; i < path.length; i++) {\n    if (path[i].tagName === 'A') {\n      return path[i];\n    }\n  }\n  \n  return null;\n};\n\n/**\n * Check if a link should be handled by the router\n * @param {HTMLAnchorElement} anchor - Anchor element\n * @returns {boolean} - Whether the link should be handled\n */\nexport const shouldHandleLink = (anchor) => {\n  // Get the href attribute\n  const href = anchor.getAttribute('href');\n  \n  // Skip if no href\n  if (!href) {\n    return false;\n  }\n  \n  // Skip if it's an external link\n  if (href.startsWith('http') || href.startsWith('//')) {\n    return false;\n  }\n  \n  // Skip if it has a target\n  if (anchor.hasAttribute('target')) {\n    return false;\n  }\n  \n  // Skip if it's a download link\n  if (anchor.hasAttribute('download')) {\n    return false;\n  }\n  \n  // Skip if it's an anchor link\n  if (href.startsWith('#')) {\n    return false;\n  }\n  \n  // Skip if it's a file link (has extension)\n  if (href.match(/\\.\\w+$/)) {\n    return false;\n  }\n  \n  return true;\n};\n\nexport default {\n  pathToRegex,\n  extractParams,\n  normalizePath,\n  findAnchorInPath,\n  shouldHandleLink\n};","/**\n * Transition effects for page changes\n */\n\n/**\n * No transition effect\n * @returns {Function} Transition function\n */\nexport const none = () => {\n  return async (oldContent, newContent, rootElement) => {\n    rootElement.innerHTML = newContent;\n    return Promise.resolve();\n  };\n};\n\n/**\n * Fade transition effect\n * @param {Object} options - Transition options\n * @param {number} options.duration - Transition duration in ms\n * @returns {Function} Transition function\n */\nexport const fade = (options = {}) => {\n  const duration = options.duration || 150;\n  const onComplete = options.onComplete || (() => {});\n  \n  return async (oldContent, newContent, rootElement) => {\n    return new Promise((resolve) => {\n      // Create a full-screen overlay to hide everything during transition\n      const transitionOverlay = document.createElement('div');\n      transitionOverlay.className = 'transition-overlay';\n      transitionOverlay.style.position = 'fixed';\n      transitionOverlay.style.top = '0';\n      transitionOverlay.style.left = '0';\n      transitionOverlay.style.width = '100vw';\n      transitionOverlay.style.height = '100vh';\n      transitionOverlay.style.backgroundColor = 'var(--background-color, #ffffff)';\n      transitionOverlay.style.zIndex = '9999';\n      transitionOverlay.style.opacity = '0';\n      transitionOverlay.style.transition = `opacity ${duration}ms ease-in-out`;\n      \n      // Add the overlay to the body\n      document.body.appendChild(transitionOverlay);\n      \n      // Fade in the overlay\n      setTimeout(() => {\n        transitionOverlay.style.opacity = '1';\n      }, 0);\n      \n      // Wait for the fade-in to complete\n      setTimeout(() => {\n        // Replace the content\n        if (newContent instanceof DocumentFragment) {\n          // Clear the root element\n          rootElement.innerHTML = '';\n          // Append the DocumentFragment\n          rootElement.appendChild(newContent.cloneNode(true));\n        } else if (typeof newContent === 'string') {\n          // Set the HTML content\n          rootElement.innerHTML = newContent;\n        } else {\n          console.error('Unsupported content type:', typeof newContent);\n          rootElement.innerHTML = String(newContent);\n        }\n        \n        // Fade out the overlay\n        transitionOverlay.style.opacity = '0';\n        \n        // Remove the overlay after the transition completes\n        setTimeout(() => {\n          if (document.body.contains(transitionOverlay)) {\n            document.body.removeChild(transitionOverlay);\n          }\n          \n          // Call the onComplete callback\n          onComplete();\n          \n          // Clean up any other transition overlays that might be stuck\n          const overlays = document.querySelectorAll('.transition-overlay');\n          overlays.forEach(overlay => {\n            if (document.body.contains(overlay) && overlay !== transitionOverlay) {\n              console.log('Removing stale transition overlay');\n              document.body.removeChild(overlay);\n            }\n          });\n          \n          resolve();\n        }, duration);\n      }, duration);\n      \n      // Safety timeout to ensure overlay is removed even if something goes wrong\n      setTimeout(() => {\n        if (document.body.contains(transitionOverlay)) {\n          console.log('Safety timeout: removing transition overlay');\n          document.body.removeChild(transitionOverlay);\n        }\n      }, duration * 3);\n    });\n  };\n};\n\n/**\n * Slide transition effect\n * @param {Object} options - Transition options\n * @param {string} options.direction - Slide direction ('left', 'right', 'up', 'down')\n * @param {number} options.duration - Transition duration in ms\n * @returns {Function} Transition function\n */\nexport const slide = (options = {}) => {\n  const direction = options.direction || 'left';\n  const duration = options.duration || 300;\n  \n  return async (oldContent, newContent, rootElement) => {\n    return new Promise((resolve) => {\n      // Create a container for the old content\n      const oldContainer = document.createElement('div');\n      oldContainer.style.position = 'absolute';\n      oldContainer.style.top = '0';\n      oldContainer.style.left = '0';\n      oldContainer.style.width = '100%';\n      oldContainer.style.height = '100%';\n      oldContainer.style.transition = `transform ${duration}ms ease-in-out`;\n      \n      // Set old content\n      if (typeof oldContent === 'string') {\n        oldContainer.innerHTML = oldContent;\n      } else {\n        console.warn('Old content is not a string, using empty content');\n        oldContainer.innerHTML = '';\n      }\n      \n      // Create a container for the new content\n      const newContainer = document.createElement('div');\n      newContainer.style.position = 'absolute';\n      newContainer.style.top = '0';\n      newContainer.style.left = '0';\n      newContainer.style.width = '100%';\n      newContainer.style.height = '100%';\n      newContainer.style.transition = `transform ${duration}ms ease-in-out`;\n      \n      // Set new content\n      if (newContent instanceof DocumentFragment) {\n        newContainer.appendChild(newContent.cloneNode(true));\n      } else if (typeof newContent === 'string') {\n        newContainer.innerHTML = newContent;\n      } else {\n        console.error('Unsupported content type:', typeof newContent);\n        newContainer.innerHTML = String(newContent);\n      }\n      \n      // Set initial positions\n      let initialTransform = '';\n      let finalTransform = '';\n      \n      switch (direction) {\n        case 'left':\n          initialTransform = 'translateX(100%)';\n          finalTransform = 'translateX(-100%)';\n          break;\n        case 'right':\n          initialTransform = 'translateX(-100%)';\n          finalTransform = 'translateX(100%)';\n          break;\n        case 'up':\n          initialTransform = 'translateY(100%)';\n          finalTransform = 'translateY(-100%)';\n          break;\n        case 'down':\n          initialTransform = 'translateY(-100%)';\n          finalTransform = 'translateY(100%)';\n          break;\n      }\n      \n      // Clear the root element and add both containers\n      rootElement.innerHTML = '';\n      rootElement.style.position = 'relative';\n      rootElement.style.overflow = 'hidden';\n      rootElement.appendChild(oldContainer);\n      rootElement.appendChild(newContainer);\n      \n      // Force a reflow to ensure the initial styles are applied\n      newContainer.getBoundingClientRect();\n      \n      // Set initial transform for the new container\n      newContainer.style.transform = 'translateX(0)';\n      \n      // Trigger the transition after a short delay\n      setTimeout(() => {\n        // Set the transform for the old container\n        oldContainer.style.transform = finalTransform;\n        \n        // Clean up after the transition\n        setTimeout(() => {\n          // Clear the root element\n          rootElement.innerHTML = '';\n          \n          // Add the new content\n          if (newContent instanceof DocumentFragment) {\n            rootElement.appendChild(newContent.cloneNode(true));\n          } else if (typeof newContent === 'string') {\n            rootElement.innerHTML = newContent;\n          } else {\n            console.error('Unsupported content type:', typeof newContent);\n            rootElement.innerHTML = String(newContent);\n          }\n          \n          // Reset styles\n          rootElement.style.position = '';\n          rootElement.style.overflow = '';\n          resolve();\n        }, duration);\n      }, 10);\n    });\n  };\n};\n\n/**\n * Custom transition effect\n * @param {Function} fn - Custom transition function\n * @returns {Function} Transition function\n */\nexport const custom = (fn) => {\n  return async (oldContent, newContent, rootElement) => {\n    return fn(oldContent, newContent, rootElement);\n  };\n};\n\nexport default {\n  none,\n  fade,\n  slide,\n  custom\n};","/**\n * Logger utility for spa-router module\n * \n * This provides consistent logging to help with debugging.\n * It wraps console methods with module name prefixing and optional log levels.\n */\n\n/**\n * Create a logger instance for a specific component\n * @param {string} componentName - Name of the component using this logger\n * @returns {Object} - Logger object with log, info, warn, error, debug methods\n */\nexport function createLogger(componentName) {\n  // Get log level from environment or default to 'info'\n  const LOG_LEVEL = (typeof process !== 'undefined' && process.env && process.env.LOG_LEVEL) || \n                    (typeof localStorage !== 'undefined' && localStorage.getItem('LOG_LEVEL')) || \n                    'info';\n  \n  // Log levels and their priorities\n  const LOG_LEVELS = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    log: 3,\n    debug: 4\n  };\n\n  // Current log level priority\n  const currentLevelPriority = LOG_LEVELS[LOG_LEVEL] || LOG_LEVELS.info;\n  \n  // Module name for all logs from this module\n  const MODULE_NAME = 'spa-router';\n  \n  /**\n   * Generic log function that prefixes the module name\n   * @param {string} level - Log level (log, info, warn, error, debug)\n   * @param {Array} args - Arguments to log\n   */\n  function logWithLevel(level, ...args) {\n    // Check if this level should be logged based on current log level\n    if (LOG_LEVELS[level] <= currentLevelPriority) {\n      const prefix = componentName \n        ? `[${MODULE_NAME}:${componentName}]` \n        : `[${MODULE_NAME}]`;\n      console[level](prefix, ...args);\n    }\n  }\n  \n  // Return logger object with methods for each log level\n  return {\n    log: (...args) => logWithLevel('log', ...args),\n    info: (...args) => logWithLevel('info', ...args),\n    warn: (...args) => logWithLevel('warn', ...args),\n    error: (...args) => logWithLevel('error', ...args),\n    debug: (...args) => logWithLevel('debug', ...args),\n    \n    // Track method calls and execution times\n    trackMethod: (methodName, method) => {\n      return function(...args) {\n        const startTime = performance.now();\n        logWithLevel('debug', `${methodName} called with:`, ...args);\n        \n        try {\n          const result = method.apply(this, args);\n          \n          // Handle promises\n          if (result instanceof Promise) {\n            return result.then(value => {\n              const endTime = performance.now();\n              logWithLevel('debug', `${methodName} completed in ${endTime - startTime}ms`);\n              return value;\n            }).catch(error => {\n              logWithLevel('error', `${methodName} failed:`, error);\n              throw error;\n            });\n          }\n          \n          const endTime = performance.now();\n          logWithLevel('debug', `${methodName} completed in ${endTime - startTime}ms`);\n          return result;\n        } catch (error) {\n          logWithLevel('error', `${methodName} failed:`, error);\n          throw error;\n        }\n      };\n    }\n  };\n}\n\n// Create a default logger for the module\nconst logger = createLogger();\n\nexport default logger;","/**\n * SPA Router using the History API\n */\nimport { pathToRegex, extractParams, normalizePath, findAnchorInPath, shouldHandleLink } from './utils.js';\nimport { fade } from './transitions.js';\nimport { createLogger } from '../logger.js';\n\n// Create a logger for the router component\nconst logger = createLogger('router');\n\n/**\n * Router class for handling SPA navigation\n */\nexport class Router {\n  /**\n   * Create a new router\n   * @param {Object} options - Router options\n   * @param {Object} options.routes - Route definitions (optional)\n   * @param {string} options.rootElement - Root element selector\n   * @param {Function} options.errorHandler - 404 error handler\n   * @param {Function} options.transition - Transition function\n   */\n  constructor(options = {}) {\n    logger.debug('Router constructor called with options:', options);\n    \n    this.routes = {};\n    this.rootElement = options.rootElement || '#app';\n    this.errorHandler = options.errorHandler || this.defaultErrorHandler;\n    this.transition = options.transition || fade({ duration: 150 });\n    this.currentRoute = null;\n    this.loading = false;\n    this.middlewares = [];\n    \n    // Register initial routes if provided\n    if (options.routes) {\n      logger.debug('Registering initial routes');\n      this.registerRoutes(options.routes);\n    }\n    \n    // Initialize\n    this.init();\n    \n    logger.info('Router instance created');\n  }\n\n  /**\n   * Initialize the router\n   */\n  init() {\n    logger.info('Router initializing...');\n    \n    // Handle initial route immediately if document is already loaded\n    if (document.readyState === 'complete' || document.readyState === 'interactive') {\n      logger.info('Document already loaded, navigating to:', window.location.pathname);\n      this.navigate(window.location.pathname, false);\n    }\n    \n    // Also handle when DOM is fully loaded\n    window.addEventListener('DOMContentLoaded', () => {\n      logger.info('DOMContentLoaded event, navigating to:', window.location.pathname);\n      this.navigate(window.location.pathname, false);\n    });\n    \n    // Handle popstate events (browser back/forward)\n    window.addEventListener('popstate', (e) => {\n      logger.info('Popstate event, navigating to:', window.location.pathname);\n      this.navigate(window.location.pathname, false);\n    });\n    \n    // Intercept all clicks at the document level (including those from Shadow DOM)\n    document.addEventListener('click', (e) => {\n      // Skip if modifier keys are pressed\n      if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n      \n      // Find anchor element in the event path\n      const anchor = findAnchorInPath(e);\n      \n      // Skip if no anchor found\n      if (!anchor) return;\n      \n      // Check if the link should be handled by the router\n      if (!shouldHandleLink(anchor)) return;\n      \n      // Get the href attribute\n      const href = anchor.getAttribute('href');\n      \n      // Prevent default behavior\n      e.preventDefault();\n      \n      // Navigate to the link\n      this.navigate(href);\n      \n      logger.debug('Intercepted click on link:', href);\n    }, { capture: true }); // Use capture to get events before they reach the shadow DOM\n  }\n\n  /**\n   * Register multiple routes\n   * @param {Object} routes - Route definitions\n   */\n  registerRoutes(routes) {\n    logger.debug('Registering routes:', Object.keys(routes));\n    Object.entries(routes).forEach(([path, routeConfig]) => {\n      this.addRoute(path, routeConfig);\n    });\n    logger.info(`Registered ${Object.keys(routes).length} routes`);\n  }\n\n  /**\n   * Add a single route\n   * @param {string} path - Route path\n   * @param {Object} routeConfig - Route configuration\n   */\n  addRoute(path, routeConfig) {\n    logger.debug('Adding route:', path);\n    \n    // Convert path to regex for matching\n    const { regex, paramNames } = pathToRegex(path);\n    \n    // Store the route with its regex and param names\n    this.routes[path] = {\n      ...routeConfig,\n      regex,\n      paramNames,\n      path\n    };\n    \n    logger.debug('Route added:', path);\n  }\n\n  /**\n   * Remove a route\n   * @param {string} path - Route path\n   */\n  removeRoute(path) {\n    delete this.routes[path];\n  }\n\n  /**\n   * Get the current route\n   * @returns {Object|null} - Current route\n   */\n  getCurrentRoute() {\n    return this.currentRoute;\n  }\n\n  /**\n   * Go back in history\n   */\n  back() {\n    window.history.back();\n  }\n\n  /**\n   * Go forward in history\n   */\n  forward() {\n    window.history.forward();\n  }\n\n  /**\n   * Add middleware\n   * @param {Function} middleware - Middleware function\n   */\n  use(middleware) {\n    this.middlewares.push(middleware);\n  }\n\n  /**\n   * Navigate to a route\n   * @param {string} path - Route path\n   * @param {boolean} pushState - Whether to push state to history\n   */\n  async navigate(path, pushState = true) {\n    logger.info(`Router navigating to: ${path}`);\n    \n    // Store the original path before normalization\n    const originalPath = path;\n    \n    // Normalize path\n    path = normalizePath(path);\n    \n    // Update history if needed - do this before any potential early returns\n    if (pushState) {\n      logger.debug('Updating history with path:', path);\n      window.history.pushState({ path }, document.title, path);\n    }\n    \n    // Skip if already loading\n    if (this.loading) {\n      logger.warn('Already loading, skipping navigation');\n      return;\n    }\n    \n    // Set loading state\n    this.loading = true;\n    \n    // Find matching route\n    const route = this.findRoute(path);\n    logger.debug('Found route:', route ? route.path : 'not found');\n    \n    // Get root element\n    const rootElement = document.querySelector(this.rootElement);\n    if (!rootElement) {\n      logger.error(`Root element \"${this.rootElement}\" not found`);\n      this.loading = false;\n      return;\n    }\n    \n    try {\n      // Get the current content for transitions\n      const oldContent = rootElement.innerHTML;\n      \n      // If route exists, run middleware\n      if (route) {\n        // Run middleware\n        const from = this.currentRoute ? this.currentRoute.path : null;\n        const to = { path, params: route.params };\n        \n        // Create a next function for middleware\n        let index = 0;\n        const next = async (nextPath) => {\n          // If nextPath is provided, navigate to it instead\n          if (nextPath) {\n            this.loading = false;\n            return this.navigate(nextPath);\n          }\n          \n          // Run the next middleware\n          if (index < this.middlewares.length) {\n            const middleware = this.middlewares[index++];\n            return middleware(to, from, next);\n          }\n          \n          // No more middleware, continue with navigation\n          return this.renderRoute(route, rootElement, oldContent);\n        };\n        \n        // Start middleware chain\n        await next();\n      } else {\n        // Handle 404\n        logger.warn('Route not found, showing 404 page for path:', originalPath);\n        \n        try {\n          // Call the error handler with the original path\n          const errorContent = this.errorHandler(originalPath, rootElement);\n          \n          // Apply transition\n          await this.transition(oldContent, errorContent, rootElement);\n        } catch (error) {\n          logger.error('Error in error handler or transition:', error);\n        }\n        \n        // Ensure any transition overlays are removed\n        setTimeout(() => {\n          const overlays = document.querySelectorAll('.transition-overlay');\n          overlays.forEach(overlay => {\n            if (document.body.contains(overlay)) {\n              document.body.removeChild(overlay);\n            }\n          });\n          \n          // Dispatch a custom event to signal that the error page has been rendered\n          document.dispatchEvent(new CustomEvent('error-page-rendered', {\n            detail: { path }\n          }));\n        }, 100);\n      }\n    } catch (error) {\n      logger.error('Error rendering route:', error);\n      \n      // Handle errors\n      rootElement.innerHTML = `<div class=\"error\">Error loading page: ${error.message}</div>`;\n    } finally {\n      // Clear loading state\n      this.loading = false;\n    }\n  }\n\n  /**\n   * Render a route\n   * @param {Object} route - Route to render\n   * @param {HTMLElement} rootElement - Root element\n   * @param {string} oldContent - Old content for transitions\n   */\n  async renderRoute(route, rootElement, oldContent) {\n    // Set current route\n    this.currentRoute = route;\n    \n    // Get view content\n    let content;\n    \n    // Check for beforeEnter guard\n    if (route.beforeEnter) {\n      // Create a next function for the guard\n      const next = (nextPath) => {\n        if (nextPath) {\n          this.loading = false;\n          return this.navigate(nextPath);\n        }\n        return true;\n      };\n      \n      // Run the guard\n      const result = await route.beforeEnter(route, this.currentRoute, next);\n      \n      // If the guard returned false or a promise that resolves to false, abort\n      if (result === false) {\n        this.loading = false;\n        return;\n      }\n    }\n    \n    try {\n      if (typeof route.view === 'function') {\n        // If view is a function, call it with params\n        logger.debug('Calling view function with params:', route.params);\n        content = await route.view(route.params);\n      } else if (typeof route.view === 'string') {\n        // If view is a string, treat it as HTML\n        logger.debug('Using string view');\n        content = route.view;\n      } else if (route.component) {\n        // If route has a component, handle it\n        logger.debug('Creating component:', route.component);\n        \n        if (typeof route.component === 'string') {\n          // If component is a string, create the element\n          const component = document.createElement(route.component);\n          \n          // Add props if provided\n          if (route.props) {\n            Object.entries(route.props).forEach(([key, value]) => {\n              component[key] = value;\n            });\n          }\n          \n          content = component.outerHTML;\n        } else if (typeof route.component === 'function') {\n          // If component is a function, it's a dynamic import\n          const module = await route.component();\n          const Component = module.default || module;\n          \n          // Create the component\n          const component = new Component(route.props);\n          content = component.render ? component.render() : component.outerHTML;\n        }\n      } else {\n        // Default to empty content\n        logger.warn('No view or component found, using empty content');\n        content = '';\n      }\n      \n      // Apply transition\n      await this.transition(oldContent, content, rootElement);\n      \n      // Call afterRender if provided\n      if (route.afterRender) {\n        logger.debug('Calling afterRender function');\n        try {\n          route.afterRender(route.params);\n        } catch (error) {\n          logger.error('Error in afterRender:', error);\n        }\n      }\n      \n      // Dispatch route changed event\n      window.dispatchEvent(new CustomEvent('route-changed', {\n        detail: { path: route.path, route }\n      }));\n      \n      // Remove the initial loading overlay if it exists\n      const initialOverlay = document.getElementById('initial-loading-overlay');\n      if (initialOverlay) {\n        initialOverlay.style.opacity = '0';\n        setTimeout(() => {\n          if (initialOverlay.parentNode) {\n            initialOverlay.parentNode.removeChild(initialOverlay);\n          }\n        }, 150);\n      }\n    } catch (error) {\n      logger.error('Error rendering route content:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find a route that matches the path\n   * @param {string} path - Route path\n   * @returns {Object|null} - Matching route or null\n   */\n  findRoute(path) {\n    // Check for exact match\n    if (this.routes[path]) {\n      return { ...this.routes[path] };\n    }\n    \n    // Special case for root path\n    if (path === '/' && this.routes['/']) {\n      return { ...this.routes['/'] };\n    }\n    \n    // Check for dynamic routes\n    for (const routePath in this.routes) {\n      const route = this.routes[routePath];\n      \n      // Skip if not a dynamic route\n      if (!routePath.includes(':')) continue;\n      \n      // Extract params\n      const params = extractParams(path, route.regex, route.paramNames);\n      \n      if (params) {\n        // Return route with params\n        return {\n          ...route,\n          params\n        };\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Default 404 error handler\n   * @param {string} path - Route path\n   * @param {HTMLElement} rootElement - Root element\n   * @returns {string} - Error page HTML\n   */\n  defaultErrorHandler(path) {\n    return `\n      <div class=\"error-page\">\n        <h1>404 - Page Not Found</h1>\n        <p>The page \"${path}\" could not be found.</p>\n        <a href=\"/\" class=\"back-link\">Go back to home</a>\n      </div>\n    `;\n  }\n}\n\nexport default Router;","/**\n * Component Loader Utility\n *\n * Handles automatic detection and loading of web components from HTML content\n */\n\n/**\n * Extracts module script sources from HTML content\n * @param {Document} doc - Parsed HTML document\n * @returns {string[]} - Array of script sources\n */\nexport function extractModuleScriptSources(doc) {\n  // Extract script tags from both body and the entire document\n  // This ensures we catch scripts at the root level of HTML fragments\n  const bodyScriptTags = Array.from(doc.body.querySelectorAll('script[type=\"module\"]'));\n  const allScriptTags = Array.from(doc.querySelectorAll('script[type=\"module\"]'));\n  \n  // Combine and deduplicate script tags\n  const scriptTags = [...new Set([...bodyScriptTags, ...allScriptTags])];\n  \n  // Extract src attributes\n  const scriptSources = scriptTags.map(script => script.getAttribute('src')).filter(src => src);\n  \n  if (scriptSources.length > 0) {\n    console.log(`Found ${scriptSources.length} module scripts:`, scriptSources);\n  }\n  \n  return scriptSources;\n}\n\n/**\n * Executes inline script tags from HTML content\n * @param {Document} doc - Parsed HTML document\n * @returns {Promise<number>} - Number of executed inline scripts\n */\n/**\n * Execute inline scripts by replacing them with new script elements\n * This forces the browser to execute the scripts\n * @param {Document} doc - Parsed HTML document\n * @returns {number} - Number of executed inline scripts\n */\nexport async function executeInlineScripts(doc) {\n  return function reexecuteInlineScripts(container) {\n    // Execute inline scripts only (ignore scripts with src)\n    const scripts = container.querySelectorAll('script:not([src])');\n    let count = scripts.length;\n    \n    scripts.forEach(oldScript => {\n      const newScript = document.createElement('script');\n      [...oldScript.attributes].forEach(attr =>\n        newScript.setAttribute(attr.name, attr.value)\n      );\n      newScript.textContent = oldScript.textContent;\n      oldScript.replaceWith(newScript); // Maintains position in DOM\n    });\n    \n    return count;\n  };\n}\n\n/**\n * Filters out script tags from HTML content\n * @param {HTMLElement} element - Element to filter scripts from\n * @param {boolean} keepScripts - Whether to keep script tags in the output (default: false)\n * @returns {DocumentFragment} - Document fragment with scripts removed or preserved\n */\nexport function filterScriptTags(element, keepScripts = false) {\n  const tempDiv = document.createElement('div');\n  \n  // Clone all child nodes, optionally excluding script tags\n  Array.from(element.children).forEach(child => {\n    if (keepScripts || child.tagName !== 'SCRIPT') {\n      tempDiv.appendChild(child.cloneNode(true));\n    }\n  });\n  \n  return tempDiv;\n}\n\n/**\n * Extracts all script tags from a document and creates new script elements\n * that will be executed when added to the DOM\n * @param {Document} doc - Parsed HTML document\n * @returns {Array<HTMLScriptElement>} - Array of new script elements\n */\nexport function extractAndCloneScripts(doc) {\n  // Get all script tags from the document\n  const scriptTags = Array.from(doc.querySelectorAll('script'));\n  \n  if (scriptTags.length > 0) {\n    console.log(`Found ${scriptTags.length} script tags to clone`);\n  }\n  \n  // Create new script elements with the same attributes and content\n  return scriptTags.map(oldScript => {\n    const newScript = document.createElement('script');\n    \n    // Copy all attributes\n    Array.from(oldScript.attributes).forEach(attr => {\n      newScript.setAttribute(attr.name, attr.value);\n    });\n    \n    // Copy the content\n    newScript.textContent = oldScript.textContent;\n    \n    // If it's a src script, ensure the URL is absolute\n    if (newScript.src && !newScript.src.startsWith('http://') && !newScript.src.startsWith('https://')) {\n      const baseUrl = window.location.origin;\n      const absoluteSrc = newScript.src.startsWith('/')\n        ? `${baseUrl}${newScript.src}`\n        : `${baseUrl}/${newScript.src}`;\n      newScript.src = absoluteSrc;\n    }\n    \n    return newScript;\n  });\n}\n\n/**\n * Creates a document fragment from HTML content and ensures scripts are properly handled\n * @param {Document} doc - Parsed HTML document\n * @returns {DocumentFragment} - Document fragment with content and scripts that will execute\n */\nexport function createFragmentWithScripts(doc) {\n  // Create a fragment to hold the content\n  const fragment = document.createDocumentFragment();\n  \n  // Clone all children from the body\n  Array.from(doc.body.children).forEach(child => {\n    // Skip script tags, we'll handle them separately\n    if (child.tagName !== 'SCRIPT') {\n      fragment.appendChild(child.cloneNode(true));\n    }\n  });\n  \n  // Extract and clone script tags\n  const scriptElements = extractAndCloneScripts(doc);\n  \n  // Add the script elements to the fragment\n  scriptElements.forEach(script => {\n    fragment.appendChild(script);\n  });\n  \n  // Extract module script sources\n  const moduleScripts = extractModuleScriptSources(doc);\n  \n  // Create and add module scripts to the fragment\n  if (moduleScripts && moduleScripts.length > 0) {\n    console.log(`Adding ${moduleScripts.length} module scripts to the fragment`);\n    \n    moduleScripts.forEach(src => {\n      // Create a new script element\n      const script = document.createElement('script');\n      script.type = 'module';\n      \n      // Convert to absolute URL if needed\n      if (src.startsWith('http://') || src.startsWith('https://')) {\n        script.src = src;\n      } else {\n        // For local scripts, create absolute URL based on current origin\n        const baseUrl = window.location.origin;\n        const absoluteSrc = src.startsWith('/')\n          ? `${baseUrl}${src}`\n          : `${baseUrl}/${src}`;\n        script.src = absoluteSrc;\n      }\n      \n      console.log(`Adding module script: ${script.src}`);\n      fragment.appendChild(script);\n    });\n  }\n  \n  return fragment;\n}\n\nexport default {\n  extractModuleScriptSources,\n  executeInlineScripts,\n  filterScriptTags,\n  extractAndCloneScripts,\n  createFragmentWithScripts\n};","/**\n * Enhanced renderer for SPA Router\n * Provides component preservation and translation support\n */\nimport { extractModuleScriptSources, executeInlineScripts, filterScriptTags } from './component-loader.js';\n\n/**\n * Create a content renderer that handles translations and component preservation\n * @param {Object} options - Renderer options\n * @param {Function} options.translateContainer - Function to translate a container\n * @param {Function} options.applyRTLToDocument - Function to apply RTL direction to document\n * @param {Boolean} options.handleScripts - Whether to handle scripts in content (default: true)\n * @param {Boolean} options.keepScripts - Whether to keep script tags in the output (default: false)\n * @returns {Function} Renderer function\n */\nexport function createRenderer(options = {}) {\n  const translateContainer = options.translateContainer || ((container) => {});\n  const applyRTLToDocument = options.applyRTLToDocument || (() => {});\n  const handleScripts = options.handleScripts !== false; // Default to true\n  const keepScripts = options.keepScripts === true; // Default to false\n\n  return async (content, element) => {\n    // Create a new container with absolute positioning (off-screen)\n    const newContainer = document.createElement('div');\n    newContainer.style.position = 'absolute';\n    newContainer.style.top = '0';\n    newContainer.style.left = '0';\n    newContainer.style.width = '100%';\n    newContainer.style.height = '100%';\n    newContainer.style.opacity = '0'; // Start hidden\n    newContainer.style.zIndex = '1'; // Above the current content\n    \n    // Handle different content types\n    let doc;\n    \n    if (content instanceof DocumentFragment) {\n      console.log('Received DocumentFragment as content');\n      // Create a temporary document to hold the fragment\n      doc = document.implementation.createHTMLDocument('');\n      \n      // Clone the fragment to avoid modifying the original\n      const clonedFragment = content.cloneNode(true);\n      \n      // Append the fragment to the document body\n      doc.body.appendChild(clonedFragment);\n    } else if (typeof content === 'string') {\n      console.log('Received string as content');\n      // Parse the content into DOM\n      const parser = new DOMParser();\n      doc = parser.parseFromString(content, 'text/html');\n    } else {\n      console.error('Unsupported content type:', typeof content);\n      throw new Error('Unsupported content type: ' + typeof content);\n    }\n    \n    // Handle scripts if enabled\n    let scriptExecutor;\n    let moduleScripts = [];\n    let scriptElements = [];\n    \n    if (handleScripts) {\n      // Extract module scripts but don't execute them yet\n      // We'll store them to execute after the DOM is updated\n      moduleScripts = extractModuleScriptSources(doc);\n      \n      // Get the script executor function to be called after content is added to DOM\n      scriptExecutor = await executeInlineScripts(doc);\n      \n      // If keepScripts is true, collect all script elements to be properly inserted later\n      if (keepScripts) {\n        console.log('Collecting script tags to properly insert them later');\n        scriptElements = Array.from(doc.querySelectorAll('script')).map(script => {\n          // Create a clone of the script element\n          const newScript = document.createElement('script');\n          \n          // Copy all attributes\n          Array.from(script.attributes).forEach(attr => {\n            newScript.setAttribute(attr.name, attr.value);\n          });\n          \n          // Copy the content\n          newScript.textContent = script.textContent;\n          \n          // Remove the original script from the DOM\n          if (script.parentNode) {\n            script.parentNode.removeChild(script);\n          }\n          \n          return newScript;\n        });\n        \n        console.log(`Collected ${scriptElements.length} script elements`);\n      } else {\n        // Filter out script tags from the content\n        const bodyWithoutScripts = filterScriptTags(doc.body, false);\n        \n        // Clear the body and append each child individually\n        while (doc.body.firstChild) {\n          doc.body.removeChild(doc.body.firstChild);\n        }\n        \n        Array.from(bodyWithoutScripts.children).forEach(child => {\n          doc.body.appendChild(child);\n        });\n      }\n    }\n    \n    // Get all existing web components in the current DOM to preserve\n    const existingComponents = {};\n    const customElements = element.querySelectorAll('*').filter(el => el.tagName.includes('-'));\n    \n    customElements.forEach(el => {\n      const id = el.tagName.toLowerCase();\n      existingComponents[id] = el;\n    });\n    \n    // Process the new content\n    Array.from(doc.body.children).forEach(child => {\n      // If it's a custom element that already exists, skip it (we'll keep the existing one)\n      if (child.tagName.includes('-') && existingComponents[child.tagName.toLowerCase()]) {\n        console.log(`Preserving existing component: ${child.tagName.toLowerCase()}`);\n      } else {\n        // Otherwise, add the new element to the container\n        newContainer.appendChild(child);\n      }\n    });\n    \n    // Translate all text in new DOM\n    if (translateContainer) {\n      translateContainer(newContainer);\n    }\n    \n    // Add preserved components back to the new container\n    Object.values(existingComponents).forEach(component => {\n      newContainer.appendChild(component);\n    });\n    \n    // Add the new container to the DOM\n    element.appendChild(newContainer);\n    \n    // Apply RTL direction if needed\n    if (applyRTLToDocument) {\n      applyRTLToDocument();\n    }\n    \n    // Short delay to ensure everything is ready, then show new content and remove old\n    setTimeout(() => {\n      // Remove all old content\n      Array.from(element.children).forEach(child => {\n        if (child !== newContainer) {\n          element.removeChild(child);\n        }\n      });\n      \n      // Show the new content by changing position and opacity\n      newContainer.style.position = 'relative';\n      newContainer.style.opacity = '1';\n      \n      // Execute inline scripts if we have a script executor\n      if (scriptExecutor) {\n        console.log('Executing inline scripts');\n        scriptExecutor(newContainer);\n      }\n      \n      // Insert collected script elements if keepScripts is true\n      if (scriptElements && scriptElements.length > 0) {\n        console.log(`Inserting ${scriptElements.length} script elements into the DOM`);\n        scriptElements.forEach(script => {\n          if (script.type === 'module') {\n            console.log(`Inserting module script: ${script.src || 'inline'}`);\n          } else {\n            console.log(`Inserting regular script: ${script.src || 'inline'}`);\n          }\n          \n          // If it's a src script, ensure the URL is absolute\n          if (script.src && !script.src.startsWith('http://') && !script.src.startsWith('https://')) {\n            const baseUrl = window.location.origin;\n            const absoluteSrc = script.src.startsWith('/')\n              ? `${baseUrl}${script.src}`\n              : `${baseUrl}/${script.src}`;\n            script.src = absoluteSrc;\n          }\n          \n          // Append to the document to execute it\n          document.head.appendChild(script);\n        });\n      }\n      \n      // Now that the DOM is updated, import and execute module scripts\n      if (moduleScripts.length > 0) {\n        console.log('Importing module scripts after DOM update');\n        \n        // Get the base URL of the current application\n        const baseUrl = window.location.origin;\n        \n        // Import each module script\n        moduleScripts.forEach(src => {\n          // Create a new script element\n          const script = document.createElement('script');\n          script.type = 'module';\n          \n          // Convert to absolute URL if needed\n          if (src.startsWith('http://') || src.startsWith('https://')) {\n            script.src = src;\n          } else {\n            // For local scripts, create absolute URL based on current origin\n            const absoluteSrc = src.startsWith('/')\n              ? `${baseUrl}${src}`\n              : `${baseUrl}/${src}`;\n            script.src = absoluteSrc;\n          }\n          \n          console.log(`Loading module script: ${script.src}`);\n          document.head.appendChild(script);\n        });\n      }\n      \n      // Dispatch a custom event to notify that the SPA transition is complete\n      window.dispatchEvent(new CustomEvent('spa-transition-end'));\n    }, 50);\n  };\n}\n\n/**\n * Create a default error handler\n * @param {Object} options - Error handler options\n * @returns {Function} Error handler function\n */\nexport function createErrorHandler(options = {}) {\n  return (path) => {\n    return `\n      <div class=\"error-page\">\n        <h1>404 - Page Not Found</h1>\n        <p>The page \"${path}\" could not be found.</p>\n        <a href=\"/\" class=\"back-link\">Go back to home</a>\n      </div>\n    `;\n  };\n}\n\nexport default {\n  createRenderer,\n  createErrorHandler\n};","/**\n * @profullstack/spa-router\n * A lightweight, feature-rich SPA router with smooth transitions and Shadow DOM support\n */\n\nimport Router from './router.js';\nimport * as transitions from './transitions.js';\nimport * as utils from './utils.js';\nimport * as renderer from './renderer.js';\nimport * as componentLoader from './component-loader.js';\nimport logger, { createLogger } from '../logger.js';\n\n// Log module initialization\nlogger.info('Initializing spa-router module');\n\n// Export the main components\nexport { Router, transitions, utils, renderer, componentLoader };\n\n// Export logger for use in other module files\nexport { logger, createLogger };\n\n// Export a default object for UMD builds\nexport default {\n  Router,\n  transitions,\n  utils,\n  renderer,\n  componentLoader\n};\n\n// Log when the module is fully loaded\nlogger.debug('spa-router module fully loaded');"],"names":["pathToRegex","path","includes","regex","RegExp","paramNames","match","map","param","slice","pattern","replace","extractParams","params","forEach","paramName","index","normalizePath","endsWith","findAnchorInPath","event","composedPath","i","length","tagName","shouldHandleLink","anchor","href","getAttribute","startsWith","hasAttribute","utils","none","async","oldContent","newContent","rootElement","innerHTML","Promise","resolve","fade","options","duration","onComplete","transitionOverlay","document","createElement","className","style","position","top","left","width","height","backgroundColor","zIndex","opacity","transition","body","appendChild","setTimeout","DocumentFragment","cloneNode","console","error","String","contains","removeChild","querySelectorAll","overlay","log","slide","direction","oldContainer","warn","newContainer","finalTransform","overflow","getBoundingClientRect","transform","custom","fn","transitions","createLogger","componentName","LOG_LEVEL","process","env","localStorage","getItem","LOG_LEVELS","info","debug","currentLevelPriority","MODULE_NAME","logWithLevel","level","args","prefix","trackMethod","methodName","method","startTime","performance","now","result","apply","this","then","value","endTime","catch","logger","Router","constructor","routes","errorHandler","defaultErrorHandler","currentRoute","loading","middlewares","registerRoutes","init","readyState","window","location","pathname","navigate","addEventListener","e","metaKey","ctrlKey","shiftKey","preventDefault","capture","Object","keys","entries","routeConfig","addRoute","removeRoute","getCurrentRoute","back","history","forward","use","middleware","push","pushState","originalPath","title","route","findRoute","querySelector","from","to","next","nextPath","renderRoute","errorContent","dispatchEvent","CustomEvent","detail","message","content","beforeEnter","view","component","props","key","outerHTML","module","default","render","afterRender","initialOverlay","getElementById","parentNode","routePath","extractModuleScriptSources","doc","bodyScriptTags","Array","allScriptTags","scriptSources","Set","script","filter","src","executeInlineScripts","container","scripts","count","oldScript","newScript","attributes","attr","setAttribute","name","textContent","replaceWith","filterScriptTags","element","keepScripts","tempDiv","children","child","extractAndCloneScripts","scriptTags","baseUrl","origin","absoluteSrc","createFragmentWithScripts","fragment","createDocumentFragment","moduleScripts","type","componentLoader","createRenderer","translateContainer","applyRTLToDocument","handleScripts","scriptExecutor","implementation","createHTMLDocument","clonedFragment","Error","parser","DOMParser","parseFromString","scriptElements","bodyWithoutScripts","firstChild","existingComponents","el","id","toLowerCase","values","head","createErrorHandler","renderer"],"mappings":"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"}